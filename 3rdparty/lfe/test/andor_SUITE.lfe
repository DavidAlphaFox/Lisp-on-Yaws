;; Copyright (c) 2010 Robert Virding. All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions
;; are met:
;;
;; 1. Redistributions of source code must retain the above copyright
;;    notice, this list of conditions and the following disclaimer.
;; 2. Redistributions in binary form must reproduce the above copyright
;;    notice, this list of conditions and the following disclaimer in the
;;    documentation and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
;; FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
;; COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;; BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
;; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
;; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
;; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
;; ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.

;; File    : andor_SUITE.lfe
;; Author  : Robert Virding
;; Purpose : Guard test suite.

;; This is a direct translation of andor_SUITE.erl except for tests
;; with guards containing ';'. We have usually removed these or been
;; careful with these as they don't handle errors the same way as 'or'
;; (which is all we have).
	 
;; -include("test_server.hrl").

;; As close as we can get to a vanilla erlang if, a case with no match.
(defmacro eif
  (args
   (fletrec ((r ([(t v . as)] `((_ (when ,t) ,v) . ,(r as)))
		([()] ())))
     `(case 1 . ,(r args)))))

(defmacro test-pat (pat expr)
  `(let* ((val ,expr)
	  (,pat val))
     val))

;; We don't have any sensible line numbers to save so we save form.
(defmacro line (expr)
  `(progn (put 'test_server_loc (tuple 'andor_SUITE ',expr))
	  ,expr))

(defmodule andor_SUITE
  (export (all 1) (t_case 1) (t_and_or 1) (t_andalso 1) (t_orelse 1)
	  (inside 1) (overlap 1) (combined 1) (in_case 1)
	  ))

(defun all
  (['suite]
   ;; test_lib:recompile(?MODULE),
   (list 't_case 't_and_or 't_andalso 't_orelse
	 'inside 'overlap 'combined 'in_case
	 )))

(defun t_case
  ([config] (when (is_list config))
   ;; We test boolean cases almost but not quite like cases
   ;; generated by andalso/orelse.
   (line (test-pat 'less (t_case_a 1 2)))
   (line (test-pat 'not_less (t_case_a 2 2)))

   (line (test-pat (tuple 'EXIT (tuple (tuple 'case_clause 'false) _))
		   (catch (t_case_b #(x y z) 2))))
   (line (test-pat (tuple 'EXIT (tuple (tuple 'case_clause 'true) _))
		   (catch (t_case_b 'a 'a))))

   (line (test-pat 'eq (t_case_c 'a 'a)))
   (line (test-pat 'ne (t_case_c 42 ())))

   (line (test-pat 't (t_case_d 'x 'x 'true)))
   (line (test-pat 'f (t_case_d 'x 'x 'false)))
   (line (test-pat 'f (t_case_d 'x 'y 'true)))
   (line (test-pat (tuple 'EXIT (tuple 'badarg _))
		   (catch (t_case_d 'x 'y 'blurf))))

   (line (test-pat 'true (catch (t_case_e #(a b) #(a b)))))
   (line (test-pat 'false (catch (t_case_e #(a b) 42))))

   (line (test-pat 'true (t_case_xy 42 100 700)))
   (line (test-pat 'true (t_case_xy 42 100 'whatever)))
   (line (test-pat 'false (t_case_xy 42 'wrong 700)))
   (line (test-pat 'false (t_case_xy 42 'wrong 'whatever)))

   (line (test-pat 'true (t_case_xy 0 'whatever 700)))
   (line (test-pat 'true (t_case_xy 0 100 700)))
   (line (test-pat 'false (t_case_xy 0 'whatever 'wrong)))
   (line (test-pat 'false (t_case_xy 0 100 'wrong)))

   'ok))

(defun t_case_a (a b)
  (case (< a b)
    ((_ . _) 'ok)
    ('true 'less)
    ('false 'not_less)
    (#(a b c) 'ok)
    (_ 'ok)))

(defun t_case_b (a b)
  (case (=:= a b)
    ('blurf 'ok)))

(defun t_case_c (a b)
  (case (not (=:= a b))
    ('true 'ne)
    ('false 'eq)))

(defun t_case_d (a b x)
  (case (and (=:= a b) x)
    ('true 't)
    ('false 'f)))

(defun t_case_e (a b)
  (case (=:= a b)
    (bool (when (is_tuple a)) (id bool))))

(defun t_case_xy (x y z)
  (let* ((r0 (t_case_x x y z))
	 (res (when (=:= res r0)) (t_case_y x y z)))
    res))

(defun t_case_x (x y z)
  (case (=:= (abs x) 42)
    ('true (=:= y 100))
    ('false (=:= z 700))))

(defun t_case_y (x y z)
  (case (=:= (abs x) 42)
    ('false (=:= z 700))
    ('true (=:= y 100))))

(defun t_and_or
  ([config] (when (is_list config))
   (line (test-pat 'true (and 'true 'true)))
   (line (test-pat 'false (and 'true 'false)))
   (line (test-pat 'false (and 'false 'true)))
   (line (test-pat 'false (and 'false 'false)))

   (line (test-pat 'true (and (id 'true) 'true)))
   (line (test-pat 'false (and (id 'true) 'false)))
   (line (test-pat 'false (and (id 'false) 'true)))
   (line (test-pat 'false (and (id 'false) 'false)))

   (line (test-pat 'true (and 'true (id 'true))))
   (line (test-pat 'false (and 'true (id 'false))))
   (line (test-pat 'false (and 'false (id 'true))))
   (line (test-pat 'false (and 'false (id 'false))))

   (line (test-pat 'true (or 'true 'true)))
   (line (test-pat 'true (or 'true 'false)))
   (line (test-pat 'true (or 'false 'true)))
   (line (test-pat 'false (or 'false 'false)))

   (line (test-pat 'true (or (id 'true) 'true)))
   (line (test-pat 'true (or (id 'true) 'false)))
   (line (test-pat 'true (or (id 'false) 'true)))
   (line (test-pat 'false (or (id 'false) 'false)))

   (line (test-pat 'true (or 'true (id 'true))))
   (line (test-pat 'true (or 'true (id 'false))))
   (line (test-pat 'true (or 'false (id 'true))))
   (line (test-pat 'false (or 'false (id 'false))))

   'ok))

(defun t_andalso
  ([config] (when (is_list config))
   (let* ((bs '(true false))
	  (ps (lc ((<- x bs) (<- y bs))
		(tuple x y))))
     (: lists foreach (lambda (p) (t_andalso_1 p)) ps))

   (line (test-pat 'true (andalso 'true 'true)))
   (line (test-pat 'false (andalso 'true 'false)))
   (line (test-pat 'false (andalso 'false 'true)))
   (line (test-pat 'false (andalso 'false 'false)))

   (line (test-pat 'false (andalso 'false 'glurf)))
   (line (test-pat 'false (andalso 'false (exit 'exit_now))))

   (line (test-pat 'true (andalso (not (id 'false)) (not (id 'false)))))
   (line (test-pat 'false (andalso (not (id 'false)) (not (id 'true)))))
   (line (test-pat 'false (andalso (not (id 'true)) (not (id 'false)))))
   (line (test-pat 'false (andalso (not (id 'true)) (not (id 'true)))))

   (line (test-pat (tuple 'EXIT (tuple 'badarg _))
		   (catch (andalso (not (id 'glurf)) (id 'true)))))
   (line (test-pat (tuple 'EXIT (tuple 'badarg _))
		   (catch (andalso (not (id 'false)) (not (id 'glurf))))))

   (line (test-pat 'false (andalso (id 'false) (not (id 'glurf)))))
   (line (test-pat 'false (andalso 'false (not (id 'glurf)))))

   'ok))

(defun t_andalso_1
  ([(tuple x y)]
   (: lfe_io format '"(andalso ~w ~w): " (list x y))
   (let* ((v0 (andalso (echo x) (echo y)))
	  (v1 (when (=:= v0 v1))
	      (eif (andalso x y) 'true 'true 'false)))
     (check v1 (and x y)))))

(defun t_orelse
  ([config] (when (is_list config))
   (let* ((bs '(true false))
	  (ps (lc ((<- x bs) (<- y bs)) (tuple x y))))
     (: lists foreach (lambda (p) (t_orelse_1 p)) ps))

   (line (test-pat 'true (orelse 'true 'true)))
   (line (test-pat 'true (orelse 'true 'false)))
   (line (test-pat 'true (orelse 'false 'true)))
   (line (test-pat 'false (orelse 'false 'false)))

   (line (test-pat 'true (orelse 'true 'glurf)))
   (line (test-pat 'true (orelse 'true (exit 'exit_now))))

   (line (test-pat 'true (orelse (not (id 'false)) (not (id 'false)))))
   (line (test-pat 'true (orelse (not (id 'false)) (not (id 'true)))))
   (line (test-pat 'true (orelse (not (id 'true)) (not (id 'false)))))
   (line (test-pat 'false (orelse (not (id 'true)) (not (id 'true)))))

   (line (test-pat (tuple 'EXIT (tuple 'badarg _))
		   (catch (orelse (not (id 'glurf)) (id 'true)))))
   (line (test-pat (tuple 'EXIT (tuple 'badarg _))
		   (catch (orelse (not (id 'true)) (not (id 'glurf))))))

   (line (test-pat 'true (orelse (id 'true) (not (id 'glurf)))))
   (line (test-pat 'true (orelse 'true (not (id 'glurf)))))

   'ok))

(defun t_orelse_1
  ([(tuple x y)]
   (: lfe_io format '"(orelse ~w ~w): " (list x y))
   (let* ((v0 (orelse (echo x) (echo y)))
	  (v1 (when (=:= v0 v1))
	      (eif (orelse x y) 'true 'true 'false)))
     (check v1 (or x y)))))

(defun inside
  ([config] (when (is_list config))
   (line (test-pat 'true (inside -8 1)))
   (line (test-pat 'false (inside -53.5 -879798)))
   (line (test-pat 'false (inside 1.0 -879)))
   (line (test-pat 'false (inside 59 -879)))
   (line (test-pat 'false (inside -11 1.0)))
   (line (test-pat 'false (inside 100 0.2)))
   (line (test-pat 'false (inside 100 1.2)))
   (line (test-pat 'false (inside -53.5 4)))
   (line (test-pat 'false (inside 1.0 5.3)))
   (line (test-pat 'false (inside 59 879)))

   'ok))

(defun inside (xm ym)
  (let* ((x -10.0)
	 (y -2.0)
	 (w 20.0)
	 (h 4.0)
	 (r0 (inside xm ym x y w h))
	 (r1 (when (=:= r0 r1))
	     (eif (andalso (=< x xm) (< xm (+ x w)) (=< y ym) (< ym (+ y h)))
		  'true 'true 'false)))
    (case (not (id r1))
      (o0
       (let ((o1 (when (=:= o0 o1))
		 (eif (not (andalso (=< x xm) (< xm (+ x w))
				    (=< y ym) (< ym (+ y h))))
		      'true 'true 'false)))
	 o1)))
    (let (((tuple r2 xm2 ym2 x2 y2 w2 h2)
	   (when (=:= r1 r2) (=:= xm xm2) (=:= ym ym2) (=:= x x2)
		 (=:= y y2) (=:= w w2) (=:= h h2))
	   (inside_guard xm ym x y w h)))
      (: lfe_io fwrite
	'"(andalso (=< ~p ~p) (< ~p ~p) (=< ~p ~p) (< ~p ~p)) ==> ~p\n"
	(list x xm xm (+ x w) y ym ym (+ y h) r1)))
    r1))

(defun inside (xm ym x y w h)
  (andalso (=< x xm) (< xm (+ x w)) (=< y ym) (< ym (+ y h))))

(defun inside_guard
  ([xm ym x y w h]
   (when (andalso (=< x xm) (< xm (+ x w)) (=< y ym) (< ym (+ y h))))
   (tuple 'true xm ym x y w h))
  ([xm ym x y w h]
   (tuple 'false xm ym x y w h)))

(defun overlap
  ([config] (when (is_list config))
   (line (test-pat 'true (overlap 7.0 2.0 8.0 0.5)))
   (line (test-pat 'true (overlap 7.0 2.0 8.0 2.5)))
   (line (test-pat 'true (overlap 7.0 2.0 5.3 2)))
   (line (test-pat 'true (overlap 7.0 2.0 0.0 100.0)))

   (line (test-pat 'false (overlap -1 2 -35 0.5)))
   (line (test-pat 'false (overlap -1 2 777 0.5)))
   (line (test-pat 'false (overlap -1 2 2 10)))
   (line (test-pat 'false (overlap 2 10 12 55.3)))

   'ok))

(defun overlap (pos1 len1 pos2 len2)
  (let* ((r0 (case pos1
	       (pos1 (when (orelse (andalso (=< pos2 pos1)
					    (< pos1 (+ pos2 len2)))
				   (andalso (=< pos1 pos2)
					    (< pos2 (+ pos1 len1)))))
		     'true)
	       (pos1 'false)))
	 (r1 (when (=:= r0 r1))
	     (orelse (andalso (=< pos2 pos1)
			      (< pos1 (+ pos2 len2)))
		     (andalso (=< pos1 pos2)
			      (< pos2 (+ pos1 len1))))))
    (id r1)))

;; -define(COMB(A,B,C), (A andalso B orelse C)).
(defmacro COMB (a b c)
  `(orelse (andalso ,a ,b) ,c))

(defun combined
  ([config] (when (is_list config))
   (line (test-pat 'false (comb 'false 'false 'false)))
   (line (test-pat 'true (comb 'false 'false 'true)))
   (line (test-pat 'false (comb 'false 'true 'false)))
   (line (test-pat 'true (comb 'false 'true 'true)))

   (line (test-pat 'false (comb 'true 'false 'false)))
   (line (test-pat 'true (comb 'true 'true 'false)))
   (line (test-pat 'true (comb 'true 'false 'true)))
   (line (test-pat 'true (comb 'true 'true 'true)))

   (line (test-pat 'false (comb 'false 'blurf 'false)))
   (line (test-pat 'true (comb 'false 'blurf 'true)))
   (line (test-pat 'true (comb 'true 'true 'blurf)))

   (line (test-pat 'false (COMB 'false 'false 'false)))
   (line (test-pat 'true (COMB 'false 'false 'true)))
   (line (test-pat 'false (COMB 'false 'true 'false)))
   (line (test-pat 'true (COMB 'false 'true 'true)))

   (line (test-pat 'false (COMB 'true 'false 'false)))
   (line (test-pat 'true (COMB 'true 'true 'false)))
   (line (test-pat 'true (COMB 'true 'false 'true)))
   (line (test-pat 'true (COMB 'true 'true 'true)))

   ;; This next one crashed the compiler!
   (line (test-pat (tuple 'EXIT (tuple 'if_clause _))
		   (catch (COMB 'true 'blurf 'false))))
   (line (test-pat 'false (COMB 'false 'blurf 'false)))
   (line (test-pat 'true (COMB 'false 'blurf 'true)))
   (line (test-pat 'true (COMB 'true 'true 'blurf)))

   'ok))

(defun comb (a b c)
  (let* ((r0 (orelse (andalso a b) c))
	 (r1 (when (=:= r0 r1))
	     (eif (orelse (andalso a b) c) 'true 'true 'false))
	 (n0 (eif (not (orelse (andalso a b) c)) 'true 'true 'false))
	 (n1 (when (=:= n0 n1))
	     (id (not r1))))
    (id r1)))

;; Test that a boolean expression in a case expression is properly
;; optimized (in particular, that the error behaviour is correct).
(defun in_case
  ([config] (when (is_list config))
   (line (test-pat 'edge_rings (in_case_1 1 1 1 1 1)))
   (line (test-pat 'not_loop (in_case_1 0.5 1 1 1 1)))
   (line (test-pat 'loop (in_case_1 0.5 0.9 1.1 1 4)))

   (line (test-pat (tuple 'EXIT (tuple 'badarith _))
		   (catch (in_case_1 1 1 1 1 0))))
   (line (test-pat (tuple 'EXIT (tuple 'badarith _))
		   (catch (in_case_1 1 1 1 1 'nan))))
   (line (test-pat (tuple 'EXIT (tuple 'badarg _))
		   (catch (in_case_1 1 1 1 'blurf 1))))
   (line (test-pat (tuple 'EXIT (tuple 'badarith _))
		   (catch (in_case_1 '(nan) 1 1 1 1))))

   'ok))

(defun in_case_1 (lenup lendw lenn rot count)
   (let* ((r0 (in_case_1_body lenup lendw lenn rot count))
	  (res (when (=:= r0 res))
	      (in_case_1_guard lenup lendw lenn rot count)))
     res))

(defun in_case_1_body (lenup lendw lenn rot count)
  ;; This is a 'cond'.
  (case (and (and (> (/ lenup count) 0.707) (> (/ lenn count) 0.707))
	     (> (abs rot) 0.707))
    ('true 'edge_rings)
    ('false
     (case (or (or (or (>= lenup 1) (>= lendw 1)) (=< lenn 1)) (> count 4))
       ('true 'not_loop)
       ('false 'loop)))))

(defun in_case_1_guard (lenup lendw lenn rot count)
  (case (andalso (> (/ lenup count) 0.707) (> (/ lenn count) 0.707)
		 (> (abs rot) 0.707))
    ('true 'edge_rings)
    ('false (when (orelse (>= lenup 1) (>= lendw 1) (=< lenn 1) (< count 4)))
	    'not_loop)
    ('false 'loop)))

(defun check (v1 v0)
  (eif (/= v1 v0) (progn (: lfe_io fwrite '"error: ~w.\n" (list v1))
			 (exit 'suite_failed))
       'true (: lfe_io fwrite '"ok: ~w.\n" (list v1))))

(defun echo (x)
  (: lfe_io fwrite '"(eval ~w); " (list x))
  x)

;; Call this function to turn off constant propagation.
(defun id (i) i)
